% Pacotes 
\documentclass[12pt]{article}
\usepackage{titlesec}
\usepackage{etoolbox}

\makeatletter
\patchcmd{\ttlh@hang}{\parindent\z@}{\parindent\z@\leavevmode}{}{}
\patchcmd{\ttlh@hang}{\noindent}{}{}{}
\makeatother
\usepackage{cmap} %impedir ligadura de fi, fl
\usepackage[T1]{fontenc} % reconhecer acentos
\usepackage[ansinew]{inputenc}
\usepackage[brazil]{babel}
\usepackage{color}
\usepackage{graphics,graphicx}
\usepackage{subfigure} % pra inserir várias figuras no mesmo ambiente
\usepackage{longtable} % para inserir tabelas extensas sem serem quebradas
\usepackage{multirow} % pra permitir mescla de linhas na tabela
%\usepackage{helvet} 			%fonte Helvetica
%\renewcommand{\familydefault}{\sfdefault}				%definir fonte sem serifa como
% padrão

%Pacotes adicionais
\usepackage[active]{srcltx}
\usepackage{mathrsfs}
\usepackage{latexsym}
\usepackage{mathtools, amssymb,
	amsmath, amsfonts, amscd, bezier, amsthm, wrapfig, multicol}
\usepackage[titletoc,toc,page]{appendix}
\renewcommand{\appendixtocname}{Apêndices}
\renewcommand{\appendixpagename}{Apêndices}

%Definição de Profundidade de Secionamento
\usepackage{titlesec}
\titleclass{\subsubsubsection}{straight}[\subsection]

\newcounter{subsubsubsection}[subsubsection]

\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}}
\renewcommand\thesubparagraph{\theparagraph.\arabic{subparagraph}}

\titleformat{\subsubsubsection}
{\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
	{3.25ex \@plus1ex \@minus.2ex}%
	{-1em}%
	{\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}
	{3.25ex \@plus1ex \@minus .2ex}%
	{-1em}%
	{\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

\makeatletter
\@addtoreset{subsubsubsection}{section}
\@addtoreset{subsubsubsection}{subsection}
\makeatother

\setcounter{secnumdepth}{6}
\setcounter{tocdepth}{6}

% Margem e espaçamento
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\renewcommand{\baselinestretch}{1.5}   % espaçamento entre linhas
\setlength{\parskip}{0.2\baselineskip} % espaçamento entre parágrafos
\usepackage{indentfirst} % indentar o primeiro parágrafo das seções
\setlength{\parindent}{1.5cm} % tamanho da indentação de parágrafo
\usepackage{setspace} % permite comandos de espaçamento entre linhas

%Cabeçalho e rodapé
\usepackage{fancyhdr}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\fancyhead[LE, LO, RE, RO]{}
\fancyfoot[CO, CE]{}
\fancyfoot[RO, RE]{\thepage}

%Versões Matemáticas
%\DeclareMathVersion{mymath}
%\SetSymbolFont{letters}{mymath}{OT1}{ptm}{m}{n}
%\SetSymbolFont{operators}{mymath}{OT1}{ptm}{m}{n}

% Teoremas
\newtheorem{teo}{Teorema}[section]
\newtheorem*{teo*}{Teorema}
\newtheorem{defin}{Definição}[section]
\newtheorem*{defin*}{Definição}
\newtheorem{prop}{Proposição}[section]
\newtheorem*{prop*}{Proposição}
\newtheorem*{sol}{Solução}
\newtheorem*{dems}{Demonstração}

% Abreviação de comandos
\newcommand{\C}{\mathbb C}
\newcommand{\R}{\mathbb R}
\newcommand{\N}{\mathbb N}
\newcommand{\Q}{\mathbb Q}
\newcommand{\Z}{\mathbb Z}
\newcommand{\I}{\mathbb I}
\newcommand{\cbrt}{\sqrt[3]}
\newcommand{\ds}{\displaystyle}
\newcommand{\Lim}[2]{\ds \lim_{#1 \to #2}}
\newcommand{\Sum}[2]{\ds \sum_{#1}^{#2}}
\newcommand{\Int}[2]{\ds \int_{#1}^{#2}}
\newcommand{\serie}{\Sum{n = 1}{\infty}}
\newcommand{\derp}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\recebe}{$\gets$ }
\newcommand{\negado}[1]{$\overline{#1}$}
\newcommand{\sizeof}[1]{\Arrowvert#1\Arrowvert}
\newcommand{\xor}{\oplus}
\newcommand{\xnor}{\odot}
\newcommand{\pulalinha}[1]{\vspace{#1\baselineskip}}
\newcommand{\bms}[2]{\textbf{#1\textsubscript{#2}}}
\newcommand{\inlinemath}[1]{$#1$}
\newcommand{\minitem}[1]{\subitem {\small $\circ$ #1}}

%Grafos e Gráficos
\usepackage{pgf,tikz}
%\usetikzlibrary{arrows}
\usepackage{tikz-qtree}
%\usetikzlibrary{trees,graphs,graphdrawing}
%\usegdlibrary{trees, layered,force}


%Referências
\usepackage[comma]{natbib}   % omit 'round' option if you prefer square brackets
\bibliographystyle{plainnat}
% - citet => Author (year)		|		- citeauthor => Author

%Resumo
\newcommand{\prof}{Ronaldo Augusto de Lara Gonçalves }
\newcommand{\disc}{Programação para Interfaceamento de Hardware e Software }
\newcommand{\discnro}{6894 }
\newcommand{\nospaceitem}{\setlength{\itemsep}{1pt}\setlength{\parskip}{0pt}\setlength{\parsep}{0pt}}

%Novos Ambientes
\newenvironment{itens}{\begin{itemize}\nospaceitem}{\end{itemize}}
\newsavebox{\mybox}
\newenvironment{solution}
{\begin{lrbox}{\mybox}\begin{minipage}{0.9\textwidth}}
		{\end{minipage}\end{lrbox}\fbox{\usebox{\mybox}}}

\newcommand\notes[1]{%
	\fbox{\begin{minipage}{0.9\textwidth}#1\end{minipage}}}

%Começo do documento
\begin{document}
	\fontfamily{ptm} % usar fonte Times New Roman
	\selectfont % ativar fonte escolhida na linha acima
%	\mathversion{mymath} % ativa a versão matemática declarada, que no caso faz os
	% números e as letras ficarem em Times New Roman
	\begin{titlepage}
\large
\hspace{-3cm}
\begin{tabular}{cc}
\multirow{4}{*}{\includegraphics[scale=0.8]{logoUEM.png}} & \\ 
& UNIVERSIDADE ESTADUAL DE
MARINGÁ
\\
& CENTRO DE TECNOLOGIA - DEPARTAMENTO DE
INFORMÁTICA \\
& GRADUAÇÃO EM CIÊNCIA DA COMPUTAÇÃO
\end{tabular}

\vspace{2cm}

\begin{center}
Relatório do Resolutor de Sistemas Lineares de\\Três Variáveis em GNU Assembly
\end{center}

\vspace{3cm}

\begin{center}
\discnro - \disc\\
\prof
\end{center}

\vspace{4cm}

\normalsize
 

\begin{tabular}{p{10cm}l}
Ricardo Henrique Brunetto & RA: 94182
\end{tabular}

\vspace{3cm}

\begin{center}
Maringá \\ 2017
\end{center}
\end{titlepage}
	
	\thispagestyle{empty}
	\newpage
	
	\section*{Introdução}
	\addcontentsline{toc}{section}{Introdução}
	
	O presente documento contém relatório do primeiro trabalho da matéria ministrada pelo \prof
	na disciplina de \disc para a turma de Bacharelado em Ciência da Computação de 2015. Tal documento apresenta uma estrutura de forma a expor o funcionamento dos principais módulos do programa, bem como salientar as limitações e possíveis exceções.
	
	O conteúdo aqui citado é advindo, além das anotações em aula e materiais disponibilizados pelo professor, da gama de referências bibliográficas por ele recomendadas e encontradas. Além disso, a fundamentação teórica é baseada em um contexto não abrangido pelo escopo da disciplina.
	
	\pulalinha{1}
	
	\section{Fundamentação Teórica}
	
	Tal seção busca apresentar a teoria na qual a implementação do Resolutor de Sistemas Lineares de Três variáveis se baseia. Não serão abordados aspectos referentes à linguagem de programação, tendo foco específico na técnica utilizada para resolver o problema em questão. Neste ínterim, utilizou-se o \textbf{Teorema de Cramer} para a resolução do sistema linear de três variáveis e o \textbf{Teorema de Sarrus} para os cálculos dos determinantes.
	
	\subsection{Teorema de Cramer}
	\label{sec:cramer}
	Existem diversos métodos de encontrar a solução de um sistema linear de $n$ variáveis, caso exista, ou mostrar sua inexistência. Um dos métodos mais eficientes é a \textbf{Regra de Cramer}, mas só pode ser utilizado quando o número de equações e de incógnitas são iguais.
	
	Assim, dadas $n$ variáveis, deve-se ter $n$ equações para utilizar o método. Será apresentado o funcionamento do método, mas sua prova formal será omitida por questões de complexidade.
	
	Dado um sistema de equações lineares de $n$ variáveis com $n$ equações, o seguinte é valido:
	$$
	\left[ \begin{array}{rccr}
	a_{11} & a_{12} & \dots & a_{1n} \\ 
	a_{21} & a_{22} & \dots & a_{2n} \\ 
	\vdots & \vdots & \ddots & \vdots \\
	a_{n1} & a_{n2} & \dots & a_{nn} \\ 
	\end{array} \right]
	\left[ \begin{array}{c}
	x_{1} \\ 
	x_{2} \\ 
	\vdots \\
	x_{n} \\ 
	\end{array} \right]
	=
	\left[ \begin{array}{c}
	z_{1} \\ 
	z_{2} \\ 
	\vdots \\
	z_{n} \\ 
	\end{array} \right]
	$$
	onde cada $a_ij$ é um coeficiente e forma matriz dos coeficientes $C$, $x_k$ é uma variável e forma a matriz das variáveis $X$, e $z_m$ é um termo independente e forma a matriz dos termos independentes $Z$. Assim, tem-se:
	$$CX = Z$$
	
	\textbf{Denomina-se \textit{matriz ampliada} a matriz $A = CZ$, ou seja, a matriz concatenada de $C$ e $Z$, sendo $n+1\times n$.}
	
	O \textbf{Teorema de Cramer} diz que
	$$x_{i} = \frac{det(C_i)}{det(C)}$$
	onde $C_i$ é uma matriz obtida através da substituição da coluna $i$ pela matriz dos termos independentes $Z$.
	
	\subsection{Teorema de Sarrus}
	\label{sec:sarrus}
	O Teorema (ou Regra) de Sarrus consiste de uma técnica que define uma fórmula fechada para o cálculo de determinantes de matrizes de ordem 3 através do conhecimento imediato de seus elementos.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\linewidth]{sarrus_rule}
		\caption{Representação da aplicação da Regra de Sarrus}
		\label{fig:sarrus}
	\end{figure}
	
	
	A técnica prática consiste em repetir as duas primeiras colunas ao lado da matriz original e: somar os produtos das diagonais principais (serão três) e então subtrair de tal resultado a somatória dos produtos das diagonais secundárias (também serão três), conforme ilustra a Figura \ref{fig:sarrus}.
	
	Contudo, em termos matemáticos, pode-se definir uma fórmula fixa que corresponda a este procedimento de duplicação de colunas. Tal fórmula é baseada no \textbf{Teorema de Laplace}. O Teorema de Laplace pode ser enunciado da seguinte maneira:
	
	\begin{center}
	\begin{solution}
		Dada uma matriz $A$ de ordem $n$, fixa-se uma linha $i$ de $A$ e o determinante de $A$ é dado por:
		$$det(A) = \sum_{j=1}^{n} a_{ij} (-1)^{i+j} det(A_{ij})$$
		onde $A_{ij}$ é a \textbf{submatriz}, de ordem $n-1$, obtida removendo-se a linha $i$ e coluna $j$ de $A$.
	\end{solution}
	\end{center}
		
	Aplicando Laplace à uma matriz $A$ de ordem 3 e fixando a primeira linha, tem-se:
	$$
	A = \left[ \begin{array}{rcr}
		a_{11} & a_{12}  & a_{13} \\ 
		a_{21} & a_{22}  & a_{23} \\ 
		a_{31} & a_{32}  & a_{33} \\ 
	\end{array} \right]
	$$
	$$
	det(A) = a_{11}(-1)^{1+1}\left| \begin{array}{rr}
	a_{22}  & a_{23} \\ 
	a_{32}  & a_{33} \\ 
	\end{array} \right| + 
	a_{12}(-1)^{1+2}\left| \begin{array}{rr}
	a_{21}  & a_{23} \\ 
	a_{31}  & a_{33} \\ 
	\end{array} \right| + 
	a_{13}(-1)^{1+3}\left| \begin{array}{rr}
	a_{21}  & a_{22} \\ 
	a_{31}  & a_{32} \\ 
	\end{array} \right|
	$$
	Aplicando a regra de determinantes de matriz de ordem 2 (que também advém de Laplace), tem-se:
	\begin{equation} \label{eq:det}
	det(A) = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{33} + a_{13}a_{21}a_{32} - a_{11}a_{23}a_{32} - a_{12}a_{23}a_{31} - a_{13}a_{22}a_{31}
	\end{equation}
	
	Assim, define-se a \textbf{Regra de Sarrus} como a equação \ref{eq:det}.
	
	\section{Estrutura e Funcionamento}
	Para que se pudesse trabalhar com melhor aproveitamento de código, desempenho e legibilidade, foram criadas funcionalidades específicas para que fossem chamadas durante a execução do programa. Cada uma das funcionalidades possui uma descrição baseada em:
	\begin{itens}
		\item \textbf{Propósito}, que descreve o que, de fato, a funcionalidade faz.
		\item \textbf{Pré-Condição}, que descreve o estado do programa que a funcionalidade espera para que cumpra seu propósito.
		\item \textbf{Pós-Condição}, que descreve o estado do programa após a execução da funcionalidade.
		\item \textbf{Registradores alterados}, que lista quais sofreram alterações, para que se torne mais fácil administrar o fluxo de execução.
	\end{itens}
	
	Evidentemente, existem outras \textit{labels} no código. Contudo, as listadas abaixo representam funcionalidades específicas que são chamadas no decorrer da execução. As seguintes funcionalidades são implementadas, a saber:
	
	\subsection*{matricial\_linear}
	\begin{itens}
		\item \textbf{Propósito}: Ir para o elemento de coordenadas matriciais através da conversão em um deslocamento linear.
		\item \textbf{Pré-Condição}:
		\subitem A linha em \verb*|%ebx|
		\subitem A coluna em \verb*|%ecx|
		\subitem Endereço inicial da matriz no topo da pilha
		\item \textbf{Pós-Condição}: Avança para o elemento [\verb*|%ebx|][\verb*|%ecx|] da matriz.
		\item \textbf{Registradores alterados}: \verb*|%edi|, \verb*|%eax| e \verb*|%ecx|
	\end{itens}


	\subsection*{proximo\_campo}
	\begin{itens}
		\item \textbf{Propósito}: Avançar um campo de tamanho fixo em um endereço de memória.
		\item \textbf{Pré-Condição}: Endereço de memória no topo da pilha
		\item \textbf{Pós-Condição}: Endereço de memória retorna à pilha deslocado em $4$ \textit{bytes}.
		\item \textbf{Registradores alterados}: \verb*|%edi|
	\end{itens}


	\subsection*{pular}
	\begin{itens}
		\item \textbf{Propósito}: Pular uma quantidade de campos de tamanho fixo em um endereço de memória.
		\item \textbf{Pré-Condição}:
		\subitem Quantidade de \textit{bytes} em \verb*|%ebx|
		\subitem Endereço de memória no topo da pilha
		\item \textbf{Pós-Condição}: Avança \verb*|%eax| \textit{bytes} no endereço de memória e o empilha.
		\item \textbf{Registradores alterados}: \verb*|%edi| e \verb*|%eax|
	\end{itens}


	\subsection*{ler\_dados}
	\begin{itens}
		\item \textbf{Propósito}: Ler as entradas do sistema e preencher a matriz ampliada.
		\item \textbf{Pré-Condição}: Endereço da matriz principal já alocado
		\item \textbf{Pós-Condição}: A matriz ampliada preenchida (coeficientes e termos independentes)
		\item \textbf{Registradores alterados}: \verb*|%edi| e \verb*|%ecx|
	\end{itens}

	\subsection*{alocar\_matriz}
	\begin{itens}
		\item \textbf{Propósito}: Aloca um bloco de memória com base em valores matriciais.
		\item \textbf{Pré-Condição}:
		\subitem Quantidade de linhas da matriz em \verb*|%eax|
		\subitem Quantidade de colunas da matriz em \verb*|%ebx|
		\item \textbf{Pós-Condição}: Endereço do primeiro elemento da matriz de inteiros alocada está em \verb*|%edi|
		\item \textbf{Registradores alterados}: \verb*|%edi|, \verb*|%eax| e \verb*|%ecx|
	\end{itens}

	\subsection*{mostrar\_sistema}
	\begin{itens}
		\item \textbf{Propósito}: Exibe o sistema linear na tela.
		\item \textbf{Pré-Condição}: Endereço do primeiro elemento da matriz ampliada em \verb*|%edi|
		\item \textbf{Pós-Condição}: -
		\item \textbf{Registradores alterados}: \verb*|%edi| e \verb*|%ecx|
	\end{itens}

	\subsection*{determinante}
	\begin{itens}
		\item \textbf{Propósito}: Calcula o determinante de uma matriz através da Regra de Sarrus.
		\item \textbf{Pré-Condição}: Endereço do primeiro elemento da matriz em \verb*|%edi|
		\item \textbf{Pós-Condição}: A variável \verb*|det_valor| possui o determinante da matriz
		\item \textbf{Registradores alterados}: \verb*|%edi|, \verb*|%eax|, \verb*|%ebx|, \verb*|%ecx| e \verb*|%edx|
	\end{itens}

	Neste ponto, aborda-se uma questão inerente ao cálculo do determinante, que se baseia na Regra de Sarrus (vide \ref{sec:sarrus}). Cada uma das \textit{labels} que compõem a funcionalidade representam o cálculo de um termo da equação \ref{eq:det}, definida pela Regra de Sarrus. Desta forma,
	\begin{itens}
		\item \verb*|calcular_primeiro_termo| \textbf{produz} $a_{11}a_{22}a_{33}$
		\item \verb*|calcular_segundo_termo| \textbf{produz} $a_{12}a_{23}a_{33}$
		\item \verb*|calcular_terceiro_termo| \textbf{produz} $a_{13}a_{21}a_{32}$
		\item \verb*|calcular_quarto_termo| \textbf{produz} $-(a_{11}a_{23}a_{32})$
		\item \verb*|calcular_quinto_termo| \textbf{produz} $-(a_{12}a_{23}a_{31})$
		\item \verb*|calcular_sexto_termo| \textbf{produz} $-(a_{13}a_{22}a_{31})$
	\end{itens}
	e cada um destes valores é somado à variável \verb*|det_valor| que, inicialmente possui o valor $0$. Desta forma, \verb*|determinante| calcula corretamente o determinante da matriz.

	\subsection*{gerar\_matriz\_sem\_z}
	\begin{itens}
		\item \textbf{Propósito}: Gera a matriz sem a última coluna. No caso, sem a matriz dos termos independentes. Em outras palavras, isola a matriz dos coeficientes (matriz quadrada) da matriz ampliada.
		\item \textbf{Pré-Condição}: Endereço de memória da matriz auxiliar alocado e em \verb*|%esi|
		\item \textbf{Pós-Condição}: Copiada a matriz quadrada dos coeficientes em \verb*|%esi|
		\item \textbf{Registradores alterados}: \verb*|%edi|, \verb*|%esi| e \verb*|%ecx|
	\end{itens}

	\subsection*{copiar\_ultima\_coluna}
	\begin{itens}
		\item \textbf{Propósito}: Substitui uma coluna da matriz pela última coluna de outra.
		\item \textbf{Pré-Condição}:
		\subitem Endereço da matriz principal (em geral, a matriz ampliada) em \verb*|%edi|
		\subitem Endereço da matriz auxiliar (que receberá a coluna) em \verb*|%esi|
		\subitem Índice da coluna da matriz auxiliar que será substituída em \verb*|%ebx|
		\item \textbf{Pós-Condição}: Avança \verb*|%eax| \textit{bytes} no endereço de memória e o empilha.
		\item \textbf{Registradores alterados}: -
	\end{itens}

	\subsection*{resolver\_sistema}
	\begin{itens}
		\item \textbf{Propósito}: Resolver o sistema linear através da aplicação da Regra de Cramer.
		\item \textbf{Pré-Condição}:
			\subitem Endereço da matriz principal (matriz ampliada) já preenchida em \verb*|%edi|
			\subitem Determinante da matriz dos coeficientes já deve ter sido calculado e armazenado em \verb*|det_D|
		\item \textbf{Pós-Condição}: Resolve o sistema e exibe os resultados à medida que são calculados.
		\item \textbf{Registradores alterados}: \verb*|%eax|, \verb*|%ebx|, \verb*|%ecx|, \verb*|%edx|, \verb*|%edi| e \verb*|%esi|
	\end{itens}

	Neste ponto, tal funcionalidade é responsável por:
	\begin{itens}
		\item Alocar uma matriz auxiliar
		\item Gerar, nessa matriz recém-alocada, a matriz dos coeficientes (matriz ampliada sem a matriz dos termos independentes)
		\item Substituir uma das colunas (iterativo, começa substituindo a primeira e se segue até a última) pela matriz dos termos independentes (a última coluna da matriz ampliada)
		\item Calcular o determinante de tal matriz
		\item Dividir pelo determinante da matriz principal dos coeficientes (\verb*|det_valor|)
		\item Exibir o resultado
	\end{itens}

	Dessa forma, a funcionalidade \verb*|resolver_sistema| resolve corretamente o sistema linear através da Regra de Cramer.

	\subsection*{inicio\_resolucao}
	\begin{itens}
		\item \textbf{Propósito}: Prepara o que é necessário para a execução do programa.
		\item \textbf{Pré-Condição}: -
		\item \textbf{Pós-Condição}:
			\subitem  Matriz ampliada alocada e preenchida
			\subitem  Determinante da matriz principal dos coeficientes calculado e armazenado em \verb*|det_D|
		\item \textbf{Registradores alterados}: \textit{N/A}
	\end{itens}

	Neste ponto que, caso o determinante principal (\verb*|det_D|) seja $0$, o programa interrompe a execução classificando o sistema como \textbf{impossível} ou \textbf{possível e indeterminado}.


	\section{Limitações e Exceções}
	
	Tal programa possui as seguintes limitações:
	\begin{itens}
		\item Calcula \textbf{unicamente} soluções para sistemas de três variáveis com três equações.
		\item Opera \textbf{apenas} sobre números inteiros e não faz verificações das entradas.
		\item Realiza divisões produzindo resultados \textbf{inteiros}.
			\subitem Dessa forma, os determinantes são arredondados, \textbf{considerando apenas suas partes inteiras}.
		\item Os ponteiros das matrizes auxiliares são alocados e desalocados a cada iteração da Regra de Cramer e a matriz principal é desalocada no final da resolução do sistema. Contudo, resíduos podem acabar sendo deixados na pilha a cada execução, o que, a longo prazo (bem longo), pode ocasionar estouro de memória.
	\end{itens}
	
	
\end{document}